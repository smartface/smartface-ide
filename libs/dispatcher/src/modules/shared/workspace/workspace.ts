if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(searchString, position) {
    var subjectString = this.toString();
    if (
      typeof position !== 'number' ||
      !isFinite(position) ||
      Math.floor(position) !== position ||
      position > subjectString.length
    ) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}
const fs = require('fs');
const path = require('path');
const uuid = require('node-uuid');
const CRC32 = require('crc-32');
const walk = require('walk');
const nsfw = require('@smartface/nsfw-prebuild');
const recursiveReaddir = require('recursive-readdir');

let counter = 0;

export type FileStatType = {
  dev: number;
  mode: number;
  nlink: number;
  uid: number;
  gid: number;
  rdev: number;
  blksize: number;
  ino: number;
  size: number;
  blocks: number;
  atime: Date;
  mtime: Date;
  ctime: Date;
  birthtime: Date;
  name: string;
  type: string;
};

const reAsset = new RegExp(
  'Assets\\' + path.sep + '\\w+\\.(?:imageset|appiconset|launchimage)\\' + path.sep
);
const exec = require('child_process').exec;
const globalModulesPath = require('global-modules');
const fileQueue = require('filequeue');

const MAX_OPEN_FILES = 5000;
const defaultIndexOptions = {
  calculateCRC: true,
  addDate: true,
  fileKeyType: 'uri',
  addScaleFactor: false
};
import Device from './device';
import getScaleFactor from './androidresourcescalefactor';
import join from '../util/join';
import { getProjectJSON } from '../projectJSONCombiner';
import { WorkspaceIndexType } from '../../../core/WorkspaceIndexTypes';
import { writeError } from '../util/write-error';

var _contentsJSONCache = {};

export type FilesDetailType = {
  [key: string]: {
    scaleFactor: number;
    scale: number;
    crc?: number;
    date?: Date;
    path?: string;
    fullPath?: string;
  };
};

/**
 * Device info provided as device options
 * @typedef {Object} Device
 * @property {string} deviceID - Random GUID generated by Emulator once
 * @property {string} deviceName - Name of the Device
 * @property {string} brandName - Name of the device manifacturer
 * @property {string} os - Operating System name of the device (iOS | Android)
 * @property {string} osVersion - OS version of the device
 * @property {string} smartfaceVersion - Smartface runtime version such as: 4.4.0.1
 * @property {Object} screen - Device screen info
 * @property {Object} screen.px - Sceen pixel values
 * @property {number} screen.px.height - Sceen height pixel value
 * @property {number} screen.px.width - Sceen width pixel value
 * @property {Object} screen.dp - Sceen dp values
 * @property {number} screen.dp.height - Sceen height dp value
 * @property {number} screen.dp.width - Sceen width dp value
 * @property {Object} screen.pt - Sceen pt values
 * @property {number} screen.pt.height - Sceen height pt value
 * @property {number} screen.pt.width - Sceen width pt value
 * @property {Array.string} resourceFolderOrder - Density based resource folder names given in order
 */

/**
 * Emulator Project Index
 * @typedef {Object} Index
 * @property {**************
 */

/**
 * @callback GetIndexCallback
 * @param {Index} data - Device index provided as data property of the callback
 */

function handleImages_iOS(device, me, index, done, options) {
  options = options || {};
  //TODO add order from device
  var order = device.imageExtensionOrder;

  var iOSImagesFolder = join(me.imagesPath, 'iOS');
  walkFolder(iOSImagesFolder, files => {
    var filesArray = Object.keys(files).filter(value => {
      var valid = true;
      options.fileNameMatch &&
        (valid =
          options.fileNameMatch.indexOf(path.parse(value).base) > -1 ||
          options.fileNameMatch[0] === '*');
      return valid;
    }, filesArray);
    var images = {};
    var newFiles = {};
    filesArray.forEach((element, idx, array) => {
      var fileInfo = path.parse(element);
      if (fileInfo.base === 'Contents.json') return; //skip Contents.json
      var imgInfo: any = getiOSImageInfo(element);
      imgInfo.fullPath = element;
      imgInfo.priority = order.indexOf(imgInfo.multiplier);

      if (!images[imgInfo.name]) images[imgInfo.name] = imgInfo;
      else {
        var other = images[imgInfo.name];
        if (other.priority > imgInfo.priority) images[imgInfo.name] = imgInfo;
      }
    });
    for (var imgInfoName in images) {
      newFiles[images[imgInfoName].fullPath] = files[images[imgInfoName].fullPath];
    }

    Object.defineProperty(newFiles, '__ofBaseFolder', {
      enumerable: false,
      configurable: true,
      value: files.__ofBaseFolder
    });

    processFolder(
      index,
      newFiles,
      'image',
      done,
      Object.assign(
        {
          os: 'iOS'
        },
        defaultIndexOptions,
        options
      )
    );
  });
}

function getiOSImageInfo(name) {
  var fileInfo = path.parse(name);
  var imgName = fileInfo.name;
  var multiplier = 1;
  reAsset.lastIndex = 0; //requires reset before any reuse
  if (reAsset.test(name)) {
    //is an asset image
    var contents = getContentsJSON(name);
    var imageRecord;
    var assetName = path.parse(path.dirname(name)).name;

    for (var i = 0; i < contents.images.length; i++) {
      imageRecord = contents.images[i];
      if (imageRecord.filename === fileInfo.base) {
        multiplier = Number(imageRecord.scale[0]);
        var ret = {
          multiplier: multiplier,
          name: assetName,
          assetName: assetName
        };
        return ret;
      }
    }
    return {
      name: '',
      multiplier: Number.MIN_VALUE
    };
  } else {
    //is not an asset image
    if (imgName.endsWith('@2x')) multiplier = 2;
    else if (imgName.endsWith('@3x')) multiplier = 3;
    switch (multiplier) {
      case 1:
        return {
          name: imgName + fileInfo.ext,
          multiplier: 1
        };
      case 2:
      case 3:
        return {
          name: imgName.substr(0, imgName.length - 3) + fileInfo.ext,
          multiplier: multiplier
        };
      default:
        throw Error('unhandeled image naming for iOS');
    }
  }
}

function getContentsJSON(name) {
  var contentsJSONPath = join(path.dirname(name), 'Contents.json');
  if (!_contentsJSONCache[contentsJSONPath]) {
    _contentsJSONCache[contentsJSONPath] = JSON.parse(fs.readFileSync(contentsJSONPath, 'utf8'));
  }
  return _contentsJSONCache[contentsJSONPath];
}

function handleImages_Android(device, me, index, done, options) {
  options = options || {};
  var androidImagesFolder = join(me.imagesPath, 'Android');
  walkFolder(androidImagesFolder, files => {
    var filesArray = Object.keys(files).filter(value => {
      var valid =
        path.relative(androidImagesFolder, value).split(path.sep).length === 2 ||
        options.fileNameMatch === '*';
      if (valid) {
        if (options.fileNameMatch) {
          valid = path.parse(value).base === options.fileNameMatch;
        }
      }
      return valid;
    }, filesArray);
    var images = {};
    var newFiles = {};
    filesArray.forEach((element, idx, array) => {
      var imgInfo = getAndroidImageInfo(element, device);
      imgInfo.fullPath = element;

      if (!images[imgInfo.name]) images[imgInfo.name] = imgInfo;
      else {
        var other = images[imgInfo.name];
        if (other.priority > imgInfo.priority) images[imgInfo.name] = imgInfo;
      }
    });
    for (var imgInfo in images) {
      newFiles[images[imgInfo].fullPath] = {
        ...files[images[imgInfo].fullPath],
        relativePath: path.parse(files[images[imgInfo].fullPath].relativePath).base
      };
    }

    Object.defineProperty(newFiles, '__ofBaseFolder', {
      enumerable: false,
      configurable: true,
      value: files.__ofBaseFolder
    });

    processFolder(
      index,
      newFiles,
      'image',
      done,
      Object.assign(
        {
          os: 'Android'
        },
        defaultIndexOptions,
        options
      )
    );
  });
}

function getAndroidImageInfo(fullPath, device) {
  var fileInfo = path.parse(fullPath);
  var density = path.parse(path.dirname(fullPath)).name;
  var priority = device.resourceFolderOrder.indexOf(density);
  return {
    name: fileInfo.name,
    density: density,
    fullPath: fullPath,
    priority: priority === -1 ? Number.MAX_VALUE : priority
  };
}

function sort(obj) {
  if (typeof obj !== 'object' || typeof obj === 'undefined' || !obj) return obj;
  var props = Object.keys(obj).sort();
  var newObject = {};
  var i, p;
  for (i = 0; i < props.length; i++) {
    p = props[i];
    newObject[p] = sort(obj[p]);
  }
  if (props.length === 0) return obj;
  return newObject;
}

function walkFolder(folder, callback) {
  /*
  const baseName = String(Math.random() * 10000) + '_' + path.basename(folder);
  console.time('⏳ Walk ' + baseName);
  */
  var files: { [key: string]: { relativePath: string; stats: FileStatType } } = {};
  Object.defineProperty(files, '__ofBaseFolder', {
    enumerable: false,
    configurable: true,
    value: folder
  });

  var walker = walk.walk(folder, {
    followLinks: true,
    filters: ['node_modules']
  });
  walker.name = folder;
  walker.on('file', fileHandler);
  walker.on('end', endHandler);

  function fileHandler(root, fileStat, next) {
    var fullPath = join(root, fileStat.name);
    var relativePath = path.relative(folder, fullPath);
    relativePath = join(relativePath.split(path.sep).join('/'));
    files[fullPath] = { relativePath, stats: fileStat };
    if (typeof next === 'function') next();
  }

  function endHandler() {
    /*
    console.timeEnd('⏳ Walk ' + baseName);
    */
    callback(files);
  }
}

function getURI(file, relativePath, schema, os) {
  reAsset.lastIndex = 0;
  if (os === 'Android') {
    var density = path.parse(path.dirname(file)).name;
    return schema + '://' + relativePath + '?density=' + density;
  } else if (os === 'iOS') {
    if (schema === 'image' && reAsset.test(relativePath)) {
      var fileInfo = path.parse(relativePath);
      var assetInfo = path.parse(fileInfo.dir);
      var contentJSONImages = _contentsJSONCache[join(path.dirname(file), 'Contents.json')].images;
      for (var i = 0; i < contentJSONImages.length; i++) {
        if (contentJSONImages[i].filename === fileInfo.base) {
          return (
            schema +
            '://' +
            assetInfo.name +
            (contentJSONImages[i].scale === '1x' ? '' : '@' + contentJSONImages[i].scale) +
            fileInfo.ext +
            '?path=' +
            encodeURIComponent(relativePath)
          );
        }
      }
      throw Error('No file found in Xcode asset content.json');
    } else {
    }
  }
  return schema + '://' + relativePath;
}

function processFolder(
  index,
  files: { [key: string]: { relativePath: string; stats: FileStatType } },
  schema,
  callback,
  options = null
) {
  options = options || defaultIndexOptions;
  index = index || {};
  index.files = index.files || {};
  let taskCount = 0,
    me = this,
    filesArray = Object.keys(files),
    fq = new fileQueue(MAX_OPEN_FILES);

  for (var i = 0; i < filesArray.length; i++) {
    options.calculateCRC && taskCount++;
    let fileKey;
    let file = filesArray[i];
    if (options.fileKeyType == 'uri') {
      fileKey = getURI(file, files[file].relativePath, schema, options.os);
    } else if (options.fileKeyType == 'path') {
      fileKey = file;
    }
    index.files[fileKey] = index.files[fileKey] || {};
    if (schema === 'script') {
      index.files[fileKey].fullPath = file;
    }
    if (options.addDate) {
      index.files[fileKey].date = files[file].stats.ctime;
    }
    options.calculateCRC && getCRC(file, fileKey);
    options.addScaleFactor && addScaleFactor(index, file, fileKey, options.addScaleFactor);
  }

  if (taskCount === 0) {
    finalize();
  }

  function finalize() {
    if (taskCount !== 0) return;
    callback.call(me, index);
  }
  /*
  //No longer needed
  function getFileStats(file, fileKey) {
    fq.stat(file, function fStat(err, stats) {
      if (err) {
        throw err;
      }
      index.files[fileKey].date = stats.ctime;
      taskCount--;
      finalize();
    });
  }
  */

  function getCRC(file, fileKey) {
    fq.readFile(file, 'binary', (err, data) => {
      if (err) {
        throw err;
      }
      index.files[fileKey].crc = CRC32.buf(data);
      taskCount--;
      finalize();
    });
  }

  function addScaleFactor(index, file, fileKey, device) {
    var imgInfo;
    var targetObject = index.files[fileKey];
    if (device.os === 'iOS') {
      imgInfo = getiOSImageInfo(file);
      targetObject.imageScaleFactor = imgInfo.multiplier;
    } else if (device.os === 'Android') {
      imgInfo = getAndroidImageInfo(file, device);
      targetObject.imageScaleFactor = getScaleFactor(imgInfo.density);
    }
    targetObject.scaleWith = device.scaleFactor / targetObject.imageScaleFactor;
    isNaN(targetObject.scaleWith) && (targetObject.scaleWith = 1);
  }
}

/**
 * Workspace constructor options parameter object
 * @typedef {Object} workspaceOptions
 * @property {string} path - Path of the workspace.
 * @property {string} projectJSONPath - Path of the project.json file relative to workspace. Defaults to join(options.path, "config", "project.json")
 * @property {string} scriptsPath - Path of the scripts folder relative to workspace. Defaults to join(options.path, "scripts")
 * @property {string} imagesPath - Path of the scripts folder relative to workspace. Defaults to join(options.path, "images")
 * @property {string} assetsPath - Path of the scripts folder relative to workspace. Defaults to join(options.path, "assets")
 * @property {string} fontPath - Path of the scripts folder relative to workspace. Defaults to join(options.path, "config", "Fonts")
 * @property {string} projectID - Optinal. Unique Identifier of ProjectID. If not provided a UUID.v4 will be added to project.json and it will be used. Otherwise provided identifier will be used
 * @property {string} hashBinaries - Optinal. Should hash binaries within the index
 */

/**
 * Creates a new workspace instance with options
 * @class
 * @param {workspaceOptions} options - Required. Creates a workspace with required options
 */
export default class Workspace {
  static nodeDate = new Date();
  /** @type {string} */
  private path: string;

  /** @type {string} */
  private projectJSONPath: string;

  /** @type {string} */
  private scriptsPath: string;

  /** @type {string} */
  private settingsPath: string;

  /** @type {string} */
  private imagesPath: string;

  /** @type {string} */
  private assetsPath: string;

  /** @type {string} */
  private configPath: string;

  /** @type {string} */
  private fontPath?: string;

  /** @type {string} */
  private projectID: string;

  /** @type {bool} */
  private hashBinaries?: boolean;

  private settings: any = {};

  private project: any = {};

  private index: any;

  private device: Device;
  private id = counter++;

  private watcherEnabled: boolean;
  private watchers: any = {};
  private jsRegExp = /\.js$|\.json$|\.jsx$/;
  private tsDistPath: string;
  private nodeCrc: number;

  constructor(options) {
    this.path = options.path || '/home/ubuntu/workspace/';
    this.projectJSONPath = join(
      this.path,
      options.projectJSONPath || join('config', 'project.json')
    );
    this.scriptsPath = join(this.path, options.scriptsPath || 'scripts');
    this.settingsPath = join(this.scriptsPath, 'settings.json');
    this.imagesPath = join(this.path, options.imagesPath || 'images');
    this.assetsPath = join(this.path, options.assetsPath || 'assets');
    this.configPath = join(this.path, options.configPath || 'config');
    this.fontPath = join(this.path, join('config', 'Fonts'));
    this.projectID = options.projectID;
    this.hashBinaries = options.hashBinaries;
    this.device = options.device instanceof Device ? options.device : new Device(options.device);
    this.nodeCrc = CRC32.buf(options.securityGuid);
  }

  private async addNodeModulesToIndex(cb) {
    console.time('⏳ Walk node_modules' + this.id);
    const files = await recursiveReaddir(join(this.scriptsPath, 'node_modules'));
    files
      .filter(file => this.jsRegExp.test(file))
      .forEach(file => {
        let relativePath = path.relative(this.scriptsPath, file);
        relativePath = join(relativePath.split(path.sep).join('/'));
        this.index.files[`script://${relativePath}`] = {
          fullPath: file,
          crc: this.nodeCrc,
          date: Workspace.nodeDate
        };
      });
    console.timeEnd('⏳ Walk node_modules' + this.id);
    cb();
  }

  /**
   * Calculates index from workspace
   * @param {Device} device - Required. Device information to get correct image resources
   */
  async getIndex(): Promise<WorkspaceIndexType> {
    if (this.watcherEnabled) {
      return sort({ ...this.index, files: { ...this.index.files } });
    }
    console.time('📄 WS indexed' + this.id);
    this.settings = {};
    this.imagesPath;
    const jsonObj = await getProjectJSON(path.dirname(this.projectJSONPath));
    let index = Object.assign({}, jsonObj, {
      files: {},
      projectID: ''
    }) as WorkspaceIndexType;
    this.index = index;
    this.settingsPath;
    let taskCount = 3;

    return new Promise((resolve, reject) => {
      const setBinaryHashes = () => {
        const playerFolder = join(globalModulesPath, 'smartface', 'bin');
        var playerPath;
        var playerName;
        var fileHashes = {};
        if (this.device.os === 'iOS') {
          playerName = 'iOS_Player.zip';
        } else {
          if (this.device.cpu === 'x86') {
            playerName = 'SmartfacePlayer-x86.zip';
          } else {
            playerName = 'SmartfacePlayer.zip';
          }
        }
        playerPath = join(playerFolder, playerName);
        fileHashes[playerPath] = true;
        if (index && index.build && index.build.input) {
          var osKey = this.device.os.toLocaleLowerCase();
          var pluginConfigSection = index.build.input[osKey] && index.build.input[osKey].plugins;
          if (pluginConfigSection) {
            for (var i in pluginConfigSection) {
              var p = pluginConfigSection[i];
              if (typeof p === 'object') {
                p = p.active && p.path;
              }
              if (p) {
                p = join(this.path, p);
                fileHashes[p] = true;
              }
            }
          }
        }
        hashMD5Files(fileHashes, (err, fileHashes) => {
          if (err) throw err;
          index.config.rau = index.config.rau || {};
          index.config.rau.binary = {
            players: {},
            plugins: {}
          };
          var plugins = (index.config.rau.binary.plugins[this.device.os] = {});
          var playerHash = fileHashes[playerPath];
          var pluginList = Object.keys(fileHashes);
          var idx = pluginList.indexOf(playerPath);
          if (idx > -1) pluginList.splice(idx, 1);
          if (playerHash) {
            index.config.rau.binary.players[playerName] = playerHash;
          }
          for (var i in pluginList) {
            var p = pluginList[i];
            var pName = path.basename(p);
            plugins[pName] = fileHashes[p];
          }
          done();
        });
      };
      const updateScriptsPath = index => {
        var iOSScripts = index.build.input.ios.scripts,
          androidScripts = index.build.input.android.scripts;

        if (!iOSScripts || !androidScripts || iOSScripts != androidScripts) {
          return;
        }

        this.scriptsPath = join(this.path, iOSScripts);
        this.settingsPath = join(this.scriptsPath, 'settings.json');
      };
      const done = () => {
        taskCount--;
        if (taskCount !== 0) return;
        index = sort(index);
        this.startWatcher();
        console.timeEnd('📄 WS indexed' + this.id);
        resolve(index);
      };
      index.projectID = this.getProjectID(true);
      index.files = {};
      _contentsJSONCache = {};
      updateScriptsPath(index);
      ++taskCount;
      this.addNodeModulesToIndex(done);
      try {
        delete require.cache[this.settingsPath];
        this.settings = require(this.settingsPath);
      } catch (e) {
        console.error(e);
        throw new Error('No settings file found');
      }

      if (this.hashBinaries) {
        taskCount++;
        setBinaryHashes();
      }

      walkFolder(join(this.assetsPath), files => {
        processFolder(index, files, 'asset', done, null);
      });

      if (
        this.settings &&
        this.settings.config &&
        this.settings.config.paths &&
        this.settings.config.paths.output
      ) {
        const output = this.settings.config.paths.output;

        if (output.acceptedExtensions && output.acceptedExtensions.length) {
          this.jsRegExp = new RegExp(
            output.acceptedExtensions.map(ext => escapeRegExp(ext)).join('$|') + '$'
          );
        }
        if (output.root) {
          taskCount += 1;
          this.tsDistPath = join(this.path, output.root);
          console.log('- Root: ', this.tsDistPath);
          walkFolder(this.tsDistPath, files => {
            processFolder(
              index,
              elimaneteUnnecessaryScriptsFiles(files, this.jsRegExp),
              'script',
              done
            );
          });
        }
        if (output.include && output.include.length) {
          taskCount++;
          console.log('- Inc: ', output.include);
          walkFolder(join(this.scriptsPath), files => {
            processFolder(
              index,
              elimaneteUnnecessaryScriptsFiles(files, this.jsRegExp),
              'script',
              done,
              {
                ...defaultIndexOptions
                /*
                calculateCRC: false,
                addDate: false
                */
              }
            );
          });
        }
      } else {
        taskCount += 1;
        walkFolder(join(this.scriptsPath), files => {
          processFolder(
            index,
            elimaneteUnnecessaryScriptsFiles(files, this.jsRegExp),
            'script',
            done
          );
        });
      }

      walkFolder(join(this.fontPath), files => {
        processFolder(index, files, 'font', done);
      });

      var otherMapping = [
        {
          path: join(this.configPath, 'defaults.xml'),
          scheme: 'config',
          relativeTo: this.configPath
        }
      ];

      const handleOther = () => {
        var handled = [];
        var mapping;
        for (var i = 0; i < otherMapping.length; i++) {
          mapping = otherMapping[i];
          if (mapping.os && mapping.os !== this.device.os) {
            handled.push(i);
            continue;
          }
          fs.stat(mapping.path, (err, stats) => {
            if (err) return;
            taskCount++;
            var fileObject = {};
            fileObject[mapping.path] = path.relative(mapping.relativeTo, mapping.path);
            processFolder(index, fileObject, mapping.scheme, done);
          });
        }
      };

      handleOther();
      this.handleImages(done);
    });
  }

  private handleImages(done) {
    let handleImages = handleImages_iOS;
    if (this.device.os === 'Android') {
      handleImages = handleImages_Android;
    }
    handleImages(this.device, this, this.index, done, {});
  }

  private async filterChangedEvents(events: any, folder: string) {
    const files = {};
    await Promise.all(
      events
        .filter(e => e.action !== nsfw.actions.RENAMED && e.action !== nsfw.actions.DELETED)
        .map(async event => {
          const fullPath = path.join(
            event.newDirectory || event.directory,
            event.newFile || event.file
          );
          return new Promise((resolve, reject) => {
            fs.stat(fullPath, (err, stats) => {
              if (err) {
                return reject(err);
              }
              if (stats.isDirectory()) {
                return resolve('');
              }
              let relativePath = path.relative(folder, fullPath);
              relativePath = join(relativePath.split(path.sep).join('/'));
              files[fullPath] = { relativePath, stats };
              resolve(fullPath);
            });
          });
        })
    );
    return files;
  }

  private eventsRemoveHandler(events: any) {
    events
      .filter(e => e.action === nsfw.actions.RENAMED || e.action === nsfw.actions.DELETED)
      .forEach(event => {
        const filename = path.join(
          event.directory || event.newDirectory,
          event.file || event.newFile
        );
        if (event.action === nsfw.actions.RENAMED) {
          const oldFilename = path.join(event.directory, event.oldFile || event.file);
          delete this.index.files[oldFilename];
        } else if (event.action === nsfw.actions.DELETED) {
          delete this.index.files[filename];
        }
      });
  }

  public stopWatcher() {
    if (this.watcherEnabled) {
      console.info('⏱️ Stopping watcher...');
      Object.keys(this.watchers).forEach(k => {
        try {
          this.watchers[k].stop();
        } catch (e) {
          console.warn('ignore watcher.stop: ', k);
        }
      });
      this.watcherEnabled = false;
    }
  }
  //@ts-ignore
  private startWatcher() {
    console.log('⏰ Starting watcher...');
    this.stopWatcher();
    nsfw(
      this.assetsPath,
      async events => {
        this.eventsRemoveHandler(events);
        const files = await this.filterChangedEvents(events, this.assetsPath);
        console.log('⏰ W- Assets: Processing... ');
        processFolder(
          this.index,
          files,
          'asset',
          () => {
            console.log('W- Assets: Done. ');
          },
          null
        );
      },
      {
        errorCallback(errors) {
          writeError(errors, 'W- Assets Error');
        }
      }
    ).then(watcher => {
      this.watchers['assets'] = watcher;
      console.info('Workspace watcher "assets" start...');
      return watcher.start();
    });
    nsfw(
      this.scriptsPath,
      async _events => {
        const events = _events.filter(e => this.jsRegExp.test(e.newFile || e.file));
        if (!events.length) {
          return;
        }
        this.eventsRemoveHandler(events);
        const files = await this.filterChangedEvents(events, this.scriptsPath);
        console.log('⏰W- Scripts: Processing... ');
        processFolder(
          this.index,
          files,
          'script',
          () => {
            console.log('W- Scripts: Done. ');
          },
          null
        );
      },
      {
        errorCallback(errors) {
          writeError(errors, 'W- Scripts Error');
        }
      }
    ).then(watcher => {
      this.watchers['script'] = watcher;
      console.info('Workspace watcher "scripts" start...');
      return watcher.start();
    });
    if (this.tsDistPath) {
      console.info('Watcher TS path: ', path.relative(this.path, this.tsDistPath));
      nsfw(
        this.tsDistPath,
        async _events => {
          const events = _events.filter(e => this.jsRegExp.test(e.newFile || e.file));
          if (!events.length) {
            return;
          }
          this.eventsRemoveHandler(events);
          const files = await this.filterChangedEvents(events, this.tsDistPath);
          console.log('⏰ W- TSScripts: Processing... ');
          processFolder(
            this.index,
            files,
            'script',
            () => {
              console.log('W- TSScripts: Done. ');
            },
            null
          );
        },
        {
          errorCallback(errors) {
            writeError(errors, 'W- TSScripts Error');
          }
        }
      ).then(watcher => {
        this.watchers['tsscript'] = watcher;
        console.info('Workspace watcher "tsscripts" start...');
        return watcher.start();
      });
    }
    nsfw(
      this.fontPath,
      async events => {
        this.eventsRemoveHandler(events);
        const files = await this.filterChangedEvents(events, this.fontPath);
        console.log('⏰ W- Fonts: Processing... ');
        processFolder(
          this.index,
          files,
          'font',
          () => {
            console.log('W- Fonts: Done. ');
          },
          null
        );
      },
      {
        errorCallback(errors) {
          writeError(errors, 'W- Fonts Error');
        }
      }
    ).then(watcher => {
      this.watchers['font'] = watcher;
      console.info('Workspace watcher "fonts" start...');
      return watcher.start();
    });
    nsfw(
      this.imagesPath,
      async events => {
        console.log('⏰ W- Images: Processing... ');
        this.handleImages(() => {
          console.log('W- Images: Done. ');
        });
      },
      {
        errorCallback(errors) {
          writeError(errors, 'W- Images Error');
        }
      }
    ).then(watcher => {
      this.watchers['images'] = watcher;
      console.info('Workspace watcher "images" start...');
      return watcher.start();
    });
    this.watcherEnabled = true;
  }

  /**
   * Calculates index from workspace
   * @param {Device} device - Required. Device information to get correct image resources
   * @param {String} - Optional. Filters by image name
   * @param {GetIndexCallback} - Required. When provided performs asynch operation
   */
  async getImage(
    device: Device,
    imageName?: string | string[],
    full?: boolean
  ): Promise<FilesDetailType> {
    if (!(device instanceof Device)) device = new Device(device);
    full = !!full;
    return new Promise(async (resolve, reject) => {
      const jsonObj = await getProjectJSON(path.dirname(this.projectJSONPath));
      const index = Object.assign({}, jsonObj, {
        files: {},
        projectID: ''
      });
      let handleImages = handleImages_iOS;
      if (device.os === 'iOS') {
        if (imageName) {
          var pp = path.parse(imageName);
          if (pp.name.endsWith('@2x') || pp.name.endsWith('@3x')) {
            pp.name = pp.name.substring(0, pp.name.length - 3);
          }
          imageName = [pp.name + pp.ext, pp.name + '@2x' + pp.ext, pp.name + '@3x' + pp.ext];
        }
      } else if (device.os === 'Android') {
        handleImages = handleImages_Android;
      }
      handleImages(device, this, index, index => resolve(index.files), {
        calculateCRC: full,
        addDate: full,
        fileKeyType: 'path',
        addScaleFactor: device,
        fileNameMatch: imageName
      });
    });
  }

  /**
   * This callback is provided as function to getProjectID as a parameter
   * @callback getProjectIDCallback
   * @param {string} projectID - Retrieved from project.json
   */

  /**
   * Gets project unique identifier from project.json in a Smartface workspace
   * @param {boolean} withSave - Optional. If projectID is missing from project.json, creates a new one, saves to project.json and retrieves it. Otherwise if missing it will throw error.
   * @param {getProjectIDCallback} callback - Optional. Asynch call function as parameter. If provided, all operations will be synch.
   * @returns {undefined} - If callback parameter is provided will return undefined, otherwise will return projectID
   * @throws If project.json does not have projectID and withSave parameter is provided as false or not provided at all
   */
  getProjectID(withSave, callback?: Function) {
    if (typeof callback === 'undefined' && typeof withSave === 'function') {
      return this.getProjectID(false, withSave);
    }

    const parseProjectJSONForID = (err, data) => {
      if (err) throw err;
      this.project = JSON.parse(data);
      if (!this.project.projectID) {
        if (!withSave) {
          throw Error(
            'projectID is missing in project.json.' +
              '\nPlease update project.json file with a valid id or call this ' +
              'method withSave option'
          );
        } else {
          this.project.projectID = uuid.v4();
          data = JSON.stringify(this.project, null, 4);
          if (callback) {
            fs.writeFile(this.projectJSONPath, data, 'utf8', retrieveData);
          } else {
            try {
              fs.writeFileSync(this.projectJSONPath, data, 'utf8');
              return retrieveData(null);
            } catch (ex) {
              return retrieveData(err);
            }
          }
        }
      } else {
        return retrieveData(null);
      }
    };

    const retrieveData = err => {
      if (err) throw err;
      if (callback) {
        callback.call(this, this.project.projectID);
      } else {
        return this.project.projectID;
      }
    };

    withSave = Boolean(withSave);
    if (this.projectID) {
      if (callback) return callback(this.projectID);
      else return this.projectID;
    }
    if (callback) {
      fs.readFile(this.projectJSONPath, 'utf8', parseProjectJSONForID);
    } else {
      try {
        var data = fs.readFileSync(this.projectJSONPath, 'utf8');
        return parseProjectJSONForID(null, data);
      } catch (ex) {
        return parseProjectJSONForID(ex, null);
      }
    }
  }
}

function hashMD5(file, callback) {
  exec('md5sum ' + file, (err, stdout, stderr) => {
    if (err) {
      console.error(err);
      callback(err);
      return;
    }
    var data = stdout.substr(0, stdout.indexOf(' '));
    callback(null, data);
  });
}

function hashMD5Files(fileList, callback) {
  var files = Object.keys(fileList);
  var file = files.pop();

  function getMD5File(err, md5Value) {
    if (err) return console.error(err);
    fileList[file] = md5Value || null;
    file = files.pop();
    if (file) {
      hashMD5(file, getMD5File);
    } else {
      callback(null, fileList);
    }
  }
  if (file) {
    hashMD5(file, getMD5File);
  } else {
    callback(null, fileList);
  }
}

function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

function elimaneteUnnecessaryScriptsFiles(files, jsRegExp: RegExp, userRegExp?: RegExp) {
  const resultFiles = {};
  Object.keys(files).forEach(key => {
    if (userRegExp && !userRegExp.test(key)) {
      // Skip
      return;
    }
    if (jsRegExp.test(key)) {
      resultFiles[key] = files[key];
    }
  });
  return resultFiles;
}
